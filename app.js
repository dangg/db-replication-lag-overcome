const express = require('express');
const mongodb = require('mongodb');
const redis = require('redis');
const bodyParser = require('body-parser'); // Ensure body-parser is included

const app = express();
const mongoClient = mongodb.MongoClient;

// Configure body-parser to parse JSON bodies
app.use(bodyParser.json());

// Configure Redis connection
const redisClient = redis.createClient({
  url: 'redis://localhost:6379' // Assuming 'redis' is the service name in docker-compose
});

// MongoDB connection URL for the primary node, without authentication
const mongoPrimaryUrl = 'mongodb://localhost:27017';

// MongoDB connection URL for the replica set, without authentication
const mongoReplicaSetUrl = 'mongodb://localhost:27018,localhost:27018/?replicaSet=rs0&readPreference=secondary';

// Connect to Redis
redisClient.connect().then(() => {
  console.log('Connected to Redis');
}).catch(err => {
  console.error('Failed to connect to Redis', err);
});

let primaryDb;
let dbReady = false;

// Function to connect to MongoDB Primary
async function connectToMongo() {
  try {
    const client = await mongoClient.connect(mongoPrimaryUrl, { useUnifiedTopology: true });
    console.log('Connected to MongoDB Primary');
    primaryDb = client.db('mydatabase');
    dbReady = true;
  } catch (err) {
    console.error('Failed to connect to MongoDB Primary', err);
    setTimeout(connectToMongo, 5000);
  }
}

// Initial connection attempt to primary
connectToMongo();

let dbReplica;
let replicaDbReady = false;

// Function to connect to MongoDB Replica Set
async function connectToMongoReplica() {
  try {
    const client = await mongoClient.connect(mongoReplicaSetUrl, { useUnifiedTopology: true });
    console.log('Connected to MongoDB Replica Set');
    dbReplica = client;
    replicaDbReady = true;
  } catch (err) {
    console.error('Failed to connect to MongoDB Replica Set', err);
    setTimeout(connectToMongoReplica, 5000);
  }
}

// Initial connection attempt to replica set
connectToMongoReplica();

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.post('/write', async (req, res) => {
  try {
    if (!dbReady) {
      throw new Error('No primary database connection.');
    }

    const collection = primaryDb.collection('newCollection');
    const insertResult = await collection.insertOne(req.body);

    // Retrieve the timestamp generated by MongoDB server and insert it into Redis
    const timestamp = insertResult.insertedId.getTimestamp();
    await redisClient.set(`timestamp:client_id`, timestamp.toString());

    console.log(timestamp.toString());
    res.status(201).send({ success: true, document: insertResult.ops, timestamp: timestamp });
  } catch (err) {
    console.error('Write operation failed', err);
    res.status(500).send({ success: false, message: err.message });
  }
});

// ... (other parts of the script remain unchanged)

app.get('/read', async (req, res) => {
  if (!replicaDbReady) {
    return res.status(503).send({ success: false, message: 'No replica database connection.' });
  }

  try {
    // Step 1: Get the latest oplog timestamp from the replica set
    const readFromSecondary = {
      readPreference: mongodb.ReadPreference.SECONDARY
    };
    
    // Step 1: Get the latest oplog timestamp from the replica set
    const oplogCollection = dbReplica.db('local').collection('oplog.rs', readFromSecondary);
    
    const oplogEntry = await oplogCollection.find({}, { projection: { ts: 1 } })
      .sort({ $natural: -1 })
      .limit(1)
      .toArray();
    
    if (oplogEntry.length === 0) {
      throw new Error('No entries in oplog.rs found. Replica set may not be fully initialized or the connected user may lack permissions.');
    }
    
    const latestOplogTimestamp = oplogEntry[0].ts;    

    console.log(latestOplogTimestamp);

    // Step 2: Get the insert timestamp from Redis
    const redisTimestampString = await redisClient.get(`timestamp:client_id`);
    const redisTimestamp = redisTimestampString ? new Date(redisTimestampString) : null;
    console.log(latestOplogTimestamp.getHighBits());
    console.log(Math.floor(redisTimestamp / 1000));
    // Step 3: Compare timestamps
    if (!redisTimestamp || latestOplogTimestamp.getHighBits() < Math.floor(redisTimestamp / 1000)) {
      // Replica is behind Redis insert, send 202 Accepted to indicate not ready
      return res.status(202).send({ success: false, message: 'Replica set is not up to date.' });
    }

    // Step 4: Fetch the record from the replica set and return it
    const record = await dbReplica.db('mydatabase').collection('newCollection').findOne({ "key": "value" });
    if (!record) {
      return res.status(404).send({ success: false, message: 'Record not found.' });
    }

    res.status(200).send({ success: true, document: record });

  } catch (err) {
    console.error('Read operation failed', err);
    res.status(500).send({ success: false, message: err.message });
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
